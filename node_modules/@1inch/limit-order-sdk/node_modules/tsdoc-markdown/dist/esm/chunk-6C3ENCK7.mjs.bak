import { createRequire } from 'module';import path from 'path';import {fileURLToPath} from 'url';const __filename = fileURLToPath(import.meta.url);const __dirname = path.dirname(__filename);const require = createRequire(import.meta.url);
import{relative as w,resolve as F}from"path/posix";import{ModifierFlags as S,ModuleKind as I,NodeFlags as K,ScriptTarget as M,SyntaxKind as o,createProgram as $,displayPartsToString as b,forEachChild as E,getCombinedModifierFlags as R,isArrowFunction as z,isClassDeclaration as P,isEnumDeclaration as V,isFunctionDeclaration as k,isIdentifier as L,isInterfaceDeclaration as B,isMethodDeclaration as O,isModuleDeclaration as j,isPropertyDeclaration as v,isPropertySignature as J,isTypeAliasDeclaration as U,isVariableDeclaration as q,isVariableStatement as Q}from"typescript";var f=({checker:e,symbol:t,doc_type:r})=>({name:t.getName(),documentation:b(t.getDocumentationComment(e)),type:e.typeToString(e.getTypeOfSymbolAtLocation(t,t.valueDeclaration)),jsDocs:t.getJsDocTags(),...r&&{doc_type:r}}),G=({checker:e,symbol:t,doc_type:r})=>{let{members:c}=t.valueDeclaration,s=c.map(u=>{var n;let y=b(u.symbol.getDocumentationComment(e)),i=(n=u.initializer)==null?void 0:n.getText();return{name:u.name.getText(),...i!==void 0&&{type:i},...y!==void 0&&y!==""&&{documentation:y}}});return{name:t.getName(),documentation:b(t.getDocumentationComment(e)),properties:s,jsDocs:t.getJsDocTags(),doc_type:r??"enum"}},H=({checker:e,symbol:t})=>{let r=f({checker:e,symbol:t,doc_type:"class"}),c=e.getTypeOfSymbolAtLocation(t,t.valueDeclaration);return r.constructors=c.getConstructSignatures().map(s=>X({checker:e,signature:s})).filter(({documentation:s})=>s!==void 0&&s!==""),r},W=e=>{let t=R(e);return(O(e)||v(e))&&e.name.kind===o.PrivateIdentifier?!1:(t&S.Export)!==0||(t&S.Public)!==0||P(e.parent)&&[S.None,S.Static].includes(t)},X=({checker:e,signature:t})=>{var c;let r={parameters:t.parameters.map(s=>f({checker:e,symbol:s})),returnType:e.typeToString(t.getReturnType()),documentation:b(t.getDocumentationComment(e))};return t.declaration&&"modifiers"in t.declaration?{...r,visibility:((c=t.declaration.modifiers)==null?void 0:c[0].kind)===o.PrivateKeyword?"private":"public"}:{...r,visibility:"public"}},x=e=>z(e)?e:E(e,x),Y=e=>[o.TypePredicate,o.TypeReference,o.FunctionType,o.ConstructorType,o.TypeQuery,o.TypeLiteral,o.ArrayType,o.TupleType,o.OptionalType,o.RestType,o.UnionType,o.IntersectionType,o.ConditionalType,o.InferType,o.ParenthesizedType,o.ThisType,o.TypeOperator,o.IndexedAccessType,o.MappedType,o.LiteralType,o.NamedTupleMember,o.TemplateLiteralType,o.ImportType].includes(e),h=e=>{if(e.parent)return q(e.parent)&&L(e.parent.name)?e.parent.name.text:h(e.parent)},_=e=>{let t=e.parent;return t?t.kind===o.SourceFile||t.kind===o.ClassDeclaration?!0:t.kind===o.FunctionDeclaration||t.kind===o.FunctionExpression||t.kind===o.ArrowFunction||t.kind===o.PropertyAssignment||t.kind===o.ObjectLiteralExpression?!1:_(t):!1},N=({checker:e,node:t,types:r,...c})=>{if(!W(t))return[];let s=[],u=({details:i,node:n})=>{s.push({...i,...g({node:n,...c})})},y=({symbol:i,doc_type:n,node:a})=>{if(!i)return;let p=f({checker:e,symbol:i,doc_type:n});u({node:a,details:p})};if(P(t)&&t.name){let i=e.getSymbolAtLocation(t.name);if(i){let n={...H({checker:e,symbol:i}),methods:[],properties:[],...g({node:t,...c})};E(t,p=>{var T,m;let l=N({node:p,checker:e,types:r,...c}),D=({fileName:d,...C})=>C;(T=n.methods)==null||T.push(...l.filter(({doc_type:d})=>d==="method"||d==="function").map(D)),(m=n.properties)==null||m.push(...l.filter(({doc_type:d})=>d==="property").map(D))}),s.push(n)}}else if(j(t))E(t,n=>{let a=N({node:n,checker:e,types:r,...c});s.push(...a)});else if(O(t)){let i=e.getSymbolAtLocation(t.name);y({symbol:i,doc_type:"method",node:t})}else if(k(t)){let i=e.getSymbolAtLocation(t.name??t);y({symbol:i,doc_type:"function",node:t})}else{let i=x(t);if(i!==void 0){let n=e.getSymbolAtLocation(i.parent.name);if(n!==void 0){let a=_(i)?void 0:h(i),p=f({checker:e,symbol:n,doc_type:"function"});u({node:t,details:{...p,name:a!==void 0?`${a}.${p.name}`:p.name}})}}else if(v(t)){let n=e.getSymbolAtLocation(t.name);y({symbol:n,doc_type:"property",node:t})}else if(Q(t)){let{declarationList:{declarations:n,flags:a}}=t;if((a&K.Const)!==0){let l=n[0].symbol;y({symbol:l,doc_type:"const",node:t})}}else if(r&&B(t)){let n=e.getSymbolAtLocation(t.name);if(n){let a=t.members.filter(l=>J(l)&&l.name!==void 0&&L(l.name)).map(l=>e.getSymbolAtLocation(l.name)).filter(l=>l!==void 0).map(l=>f({checker:e,symbol:l})),p={...f({checker:e,doc_type:"interface",symbol:n}),properties:a,...g({node:t,...c})};s.push(p)}}else if(r&&U(t)){let n=e.getSymbolAtLocation(t.name);if(n){let a=t.getChildren().find(({kind:l})=>Y(l)),p={...f({checker:e,doc_type:"type",symbol:n}),...g({node:t,...c}),type:a==null?void 0:a.getText().replace(/^"|"$/g,"")};s.push(p)}}else if(V(t)){let n=e.getSymbolAtLocation(t.name),a=G({checker:e,symbol:n});u({node:t,details:a})}}return s},A={target:M.ES2020,module:I.CommonJS,strictNullChecks:!0},g=({repo:e,node:t,sourceFile:r})=>{let c=r.fileName;if(e===void 0)return{fileName:c};let{url:s,branch:u}=e,{line:y}=r.getLineAndCharacterOfPosition(t.getStart()),i=w(process.cwd(),r.fileName),n=`${s.replace(/\/+$/,"")}/tree/${u??"main"}/${i.replace(/^\.\.\//,"")}#L${y+1}`;return{fileName:c,url:n}},et=({inputFiles:e,options:t})=>{let{compilerOptions:r,explore:c,repo:s,types:u}=t??{explore:!1,compilerOptions:A,types:!1},y=c??!1,i=u??!1,n=$(e,r??A),a=n.getSourceFiles(),p=e.map(m=>F(m)),l=a.filter(({isDeclarationFile:m,fileName:d})=>!m&&(y||p.includes(F(d)))),D=n.getTypeChecker(),T=[];for(let m of l)E(m,d=>{let C=N({checker:D,node:d,sourceFile:m,repo:s,types:i});T.push(...C)});return T};export{et as a};
//# sourceMappingURL=chunk-6C3ENCK7.mjs.map
