{
  "version": 3,
  "sources": ["../../src/lib/docs.ts"],
  "sourcesContent": ["import {relative, resolve} from 'path/posix';\nimport type {\n  ArrowFunction,\n  CompilerOptions,\n  Declaration,\n  EnumDeclaration,\n  FunctionDeclaration,\n  Node,\n  PropertyName,\n  Signature,\n  SourceFile,\n  TypeChecker,\n  Symbol as TypeScriptSymbol,\n  VariableDeclaration,\n  VariableStatement\n} from 'typescript';\nimport {\n  ModifierFlags,\n  ModuleKind,\n  NodeFlags,\n  ScriptTarget,\n  SyntaxKind,\n  createProgram,\n  displayPartsToString,\n  forEachChild,\n  getCombinedModifierFlags,\n  isArrowFunction,\n  isClassDeclaration,\n  isEnumDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isInterfaceDeclaration,\n  isMethodDeclaration,\n  isModuleDeclaration,\n  isPropertyDeclaration,\n  isPropertySignature,\n  isTypeAliasDeclaration,\n  isVariableDeclaration,\n  isVariableStatement\n} from 'typescript';\nimport type {BuildOptions, DocEntry, DocEntryConstructor, DocEntryType} from './types';\n\n/** Serialize a symbol into a json object */\nconst serializeSymbol = ({\n  checker,\n  symbol,\n  doc_type\n}: {\n  checker: TypeChecker;\n  symbol: TypeScriptSymbol;\n  doc_type?: DocEntryType;\n}): DocEntry => {\n  return {\n    name: symbol.getName(),\n    documentation: displayPartsToString(symbol.getDocumentationComment(checker)),\n    type: checker.typeToString(checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration!)),\n    jsDocs: symbol.getJsDocTags(),\n    ...(doc_type && {doc_type})\n  };\n};\n\nconst serializeEnum = ({\n  checker,\n  symbol,\n  doc_type\n}: {\n  checker: TypeChecker;\n  symbol: TypeScriptSymbol;\n  doc_type?: DocEntryType;\n}): DocEntry => {\n  const {members} = symbol.valueDeclaration as EnumDeclaration;\n\n  const properties: DocEntry[] = members.map((member) => {\n    const documentation = displayPartsToString(\n      (member as unknown as {symbol: TypeScriptSymbol}).symbol.getDocumentationComment(checker)\n    );\n\n    const type = member.initializer?.getText();\n\n    return {\n      name: member.name.getText(),\n      ...(type !== undefined && {type}),\n      ...(documentation !== undefined && documentation !== '' && {documentation})\n    };\n  });\n\n  return {\n    name: symbol.getName(),\n    documentation: displayPartsToString(symbol.getDocumentationComment(checker)),\n    properties,\n    jsDocs: symbol.getJsDocTags(),\n    doc_type: doc_type ?? 'enum'\n  };\n};\n\n/** Serialize a class symbol information */\nconst serializeClass = ({\n  checker,\n  symbol\n}: {\n  checker: TypeChecker;\n  symbol: TypeScriptSymbol;\n}): DocEntry => {\n  const details = serializeSymbol({checker, symbol, doc_type: 'class'});\n\n  // Get the construct signatures\n  const constructorType = checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration!);\n\n  details.constructors = constructorType\n    .getConstructSignatures()\n    .map((signature: Signature) => serializeSignature({checker, signature}))\n    .filter(({documentation}) => documentation !== undefined && documentation !== '');\n\n  return details;\n};\n\n/** True if this is visible outside this file, false otherwise */\nconst isNodeExportedOrPublic = (node: Node): boolean => {\n  const flags = getCombinedModifierFlags(node as Declaration);\n\n  // Check for '#' methods or properties\n  if (\n    (isMethodDeclaration(node) || isPropertyDeclaration(node)) &&\n    node.name.kind === SyntaxKind.PrivateIdentifier\n  ) {\n    return false;\n  }\n\n  return (\n    (flags & ModifierFlags.Export) !== 0 ||\n    (flags & ModifierFlags.Public) !== 0 ||\n    (isClassDeclaration(node.parent) && [ModifierFlags.None, ModifierFlags.Static].includes(flags))\n  );\n};\n\n/** Serialize a signature (call or construct) */\nconst serializeSignature = ({\n  checker,\n  signature\n}: {\n  checker: TypeChecker;\n  signature: Signature;\n}): DocEntryConstructor => {\n  const result: Omit<DocEntryConstructor, 'visibility'> = {\n    parameters: signature.parameters.map((symbol: TypeScriptSymbol) =>\n      serializeSymbol({checker, symbol})\n    ),\n    returnType: checker.typeToString(signature.getReturnType()),\n    documentation: displayPartsToString(signature.getDocumentationComment(checker))\n  };\n\n  if (!!signature.declaration && 'modifiers' in signature.declaration) {\n    return {\n      ...result,\n      visibility:\n        signature.declaration.modifiers?.[0].kind === SyntaxKind.PrivateKeyword\n          ? 'private'\n          : 'public'\n    };\n  }\n\n  return {\n    ...result,\n    visibility: 'public'\n  };\n};\n\n// https://stackoverflow.com/a/73338964/5404186\nconst findDescendantArrowFunction = (node: Node): Node | undefined => {\n  if (isArrowFunction(node)) {\n    return node;\n  }\n\n  return forEachChild(node, findDescendantArrowFunction);\n};\n\n// TODO: there is probably a better way\nconst isTypeKind = (kind: SyntaxKind): boolean => {\n  const typeKinds: SyntaxKind[] = [\n    SyntaxKind.TypePredicate,\n    SyntaxKind.TypeReference,\n    SyntaxKind.FunctionType,\n    SyntaxKind.ConstructorType,\n    SyntaxKind.TypeQuery,\n    SyntaxKind.TypeLiteral,\n    SyntaxKind.ArrayType,\n    SyntaxKind.TupleType,\n    SyntaxKind.OptionalType,\n    SyntaxKind.RestType,\n    SyntaxKind.UnionType,\n    SyntaxKind.IntersectionType,\n    SyntaxKind.ConditionalType,\n    SyntaxKind.InferType,\n    SyntaxKind.ParenthesizedType,\n    SyntaxKind.ThisType,\n    SyntaxKind.TypeOperator,\n    SyntaxKind.IndexedAccessType,\n    SyntaxKind.MappedType,\n    SyntaxKind.LiteralType,\n    SyntaxKind.NamedTupleMember,\n    SyntaxKind.TemplateLiteralType,\n    // SyntaxKind.TemplateLiteralTypeSpan, // This is more of a structural part of template literal types\n    SyntaxKind.ImportType\n  ];\n\n  return typeKinds.includes(kind);\n};\n\nconst getRootParentName = (node: Node): string | undefined => {\n  if (!node.parent) {\n    return undefined;\n  }\n\n  if (isVariableDeclaration(node.parent) && isIdentifier(node.parent.name)) {\n    return node.parent.name.text;\n  }\n\n  return getRootParentName(node.parent);\n};\n\nconst isRootOrClassLevelArrowFunction = (node: Node): boolean => {\n  const parent = node.parent;\n\n  if (!parent) {\n    return false;\n  }\n\n  if (parent.kind === SyntaxKind.SourceFile) {\n    return true;\n  }\n\n  if (parent.kind === SyntaxKind.ClassDeclaration) {\n    return true;\n  }\n\n  if (\n    parent.kind === SyntaxKind.FunctionDeclaration ||\n    parent.kind === SyntaxKind.FunctionExpression ||\n    parent.kind === SyntaxKind.ArrowFunction\n  ) {\n    return false;\n  }\n\n  if (\n    parent.kind === SyntaxKind.PropertyAssignment ||\n    parent.kind === SyntaxKind.ObjectLiteralExpression\n  ) {\n    return false;\n  }\n\n  return isRootOrClassLevelArrowFunction(parent);\n};\n\n/** visit nodes finding exported classes */\nconst visit = ({\n  checker,\n  node,\n  types,\n  ...rest\n}: {checker: TypeChecker; node: Node} & Source &\n  Required<Pick<BuildOptions, 'types'>>): DocEntry[] => {\n  // // Only consider exported nodes\n  if (!isNodeExportedOrPublic(node)) {\n    return [];\n  }\n\n  const entries: DocEntry[] = [];\n\n  const pushEntry = ({details, node}: {details: DocEntry; node: Node}) => {\n    entries.push({\n      ...details,\n      ...buildSource({\n        node,\n        ...rest\n      })\n    });\n  };\n\n  const addDocEntry = ({\n    symbol,\n    doc_type,\n    node\n  }: {\n    symbol: TypeScriptSymbol | undefined;\n    doc_type: DocEntryType;\n    node: Node;\n  }) => {\n    if (!symbol) {\n      return;\n    }\n\n    const details = serializeSymbol({checker, symbol, doc_type});\n    pushEntry({node, details});\n  };\n\n  if (isClassDeclaration(node) && node.name) {\n    // This is a top level class, get its symbol\n    const symbol = checker.getSymbolAtLocation(node.name);\n\n    if (symbol) {\n      const classEntry: DocEntry = {\n        ...serializeClass({checker, symbol}),\n        methods: [],\n        properties: [],\n        ...buildSource({\n          node,\n          ...rest\n        })\n      };\n\n      const visitChild = (node: Node) => {\n        const docEntries: DocEntry[] = visit({node, checker, types, ...rest});\n\n        // We do not need to repeat the file name for class members\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const omitFilename = ({fileName: _, ...rest}: DocEntry): Omit<DocEntry, 'fileName'> => rest;\n\n        classEntry.methods?.push(\n          ...docEntries\n            .filter(({doc_type}) => doc_type === 'method' || doc_type === 'function')\n            .map(omitFilename)\n        );\n\n        classEntry.properties?.push(\n          ...docEntries.filter(({doc_type}) => doc_type === 'property').map(omitFilename)\n        );\n      };\n\n      forEachChild(node, visitChild);\n\n      entries.push(classEntry);\n    }\n  } else if (isModuleDeclaration(node)) {\n    const visitChild = (node: Node) => {\n      const docEntries: DocEntry[] = visit({node, checker, types, ...rest});\n      entries.push(...docEntries);\n    };\n\n    // This is a namespace, visit its children\n    forEachChild(node, visitChild);\n  } else if (isMethodDeclaration(node)) {\n    const symbol = checker.getSymbolAtLocation(node.name);\n    addDocEntry({symbol, doc_type: 'method', node});\n  } else if (isFunctionDeclaration(node)) {\n    const symbol = checker.getSymbolAtLocation((node as FunctionDeclaration).name ?? node);\n    addDocEntry({symbol, doc_type: 'function', node});\n  } else {\n    const arrowFunc: Node | undefined = findDescendantArrowFunction(node);\n\n    if (arrowFunc !== undefined) {\n      const symbol = checker.getSymbolAtLocation(\n        ((arrowFunc as ArrowFunction).parent as VariableDeclaration).name\n      );\n\n      if (symbol !== undefined) {\n        const parentName = !isRootOrClassLevelArrowFunction(arrowFunc)\n          ? getRootParentName(arrowFunc)\n          : undefined;\n\n        const details = serializeSymbol({checker, symbol, doc_type: 'function'});\n        pushEntry({\n          node,\n          details: {\n            ...details,\n            name: parentName !== undefined ? `${parentName}.${details.name}` : details.name\n          }\n        });\n      }\n    } else if (isPropertyDeclaration(node)) {\n      // We test for the property after the arrow function because a public property of a class can be an arrow function.\n      const symbol = checker.getSymbolAtLocation(node.name);\n      addDocEntry({symbol, doc_type: 'property', node});\n    } else if (isVariableStatement(node)) {\n      const {\n        declarationList: {declarations, flags}\n      } = node as VariableStatement;\n\n      // https://stackoverflow.com/a/69801125/5404186\n      const isConst = (flags & NodeFlags.Const) !== 0;\n\n      if (isConst) {\n        // TODO: not sure what's the proper casting, VariableDeclaration does not contain Symbol but the test entity effectively does\n        const symbol = (declarations[0] as unknown as {symbol: TypeScriptSymbol}).symbol;\n        addDocEntry({symbol, doc_type: 'const', node});\n      }\n    } else if (types && isInterfaceDeclaration(node)) {\n      const symbol = checker.getSymbolAtLocation(node.name);\n\n      if (symbol) {\n        const members = node.members\n          .filter(\n            (member) =>\n              isPropertySignature(member) && member.name !== undefined && isIdentifier(member.name)\n          )\n          .map((member) => checker.getSymbolAtLocation(member.name as PropertyName))\n          .filter((symbol) => symbol !== undefined)\n          .map((symbol) => serializeSymbol({checker, symbol: symbol as TypeScriptSymbol}));\n\n        const interfaceEntry: DocEntry = {\n          ...serializeSymbol({checker, doc_type: 'interface', symbol}),\n          properties: members,\n          ...buildSource({\n            node,\n            ...rest\n          })\n        };\n\n        entries.push(interfaceEntry);\n      }\n    } else if (types && isTypeAliasDeclaration(node)) {\n      const symbol = checker.getSymbolAtLocation(node.name);\n\n      if (symbol) {\n        const child = node.getChildren().find(({kind}) => isTypeKind(kind));\n\n        const typeEntry: DocEntry = {\n          ...serializeSymbol({checker, doc_type: 'type', symbol}),\n          ...buildSource({\n            node,\n            ...rest\n          }),\n          type: child?.getText().replace(/^\"|\"$/g, '')\n        };\n\n        entries.push(typeEntry);\n      }\n    } else if (isEnumDeclaration(node)) {\n      const symbol = checker.getSymbolAtLocation((node as EnumDeclaration).name)!;\n      const details = serializeEnum({checker, symbol});\n      pushEntry({node, details});\n    }\n  }\n\n  return entries;\n};\n\nconst DEFAULT_COMPILER_OPTIONS: CompilerOptions = {\n  target: ScriptTarget.ES2020,\n  module: ModuleKind.CommonJS,\n  strictNullChecks: true\n};\n\ntype Source = Pick<BuildOptions, 'repo'> & {sourceFile: SourceFile};\n\nconst buildSource = ({\n  repo,\n  node,\n  sourceFile\n}: Source & {node: Node}): Pick<DocEntry, 'url' | 'fileName'> => {\n  const fileName = sourceFile.fileName;\n\n  if (repo === undefined) {\n    return {fileName};\n  }\n\n  const {url: repoUrl, branch} = repo;\n\n  const {line} = sourceFile.getLineAndCharacterOfPosition(node.getStart());\n  const filePath = relative(process.cwd(), sourceFile.fileName);\n\n  const url = `${repoUrl.replace(/\\/+$/, '')}/tree/${branch ?? 'main'}/${filePath.replace(\n    /^\\.\\.\\//,\n    ''\n  )}#L${line + 1}`;\n\n  return {\n    fileName,\n    url\n  };\n};\n\n/**\n * Build the documentation entries for the selected sources.\n *\n * @param {inputFiles: string[]; options?: CompilerOptions;} params\n * @param {string[]} params.inputFiles The list of files to scan and for which the documentation should be build.\n * @param {CompilerOptions} params.options Optional compiler options to generate the docs\n *\n * @returns An array of documentation entries\n */\nexport const buildDocumentation = ({\n  inputFiles,\n  options\n}: {\n  inputFiles: string[];\n  options?: BuildOptions;\n}): DocEntry[] => {\n  const {\n    compilerOptions,\n    explore: userExplore,\n    repo,\n    types: userTypes\n  } = options ?? {\n    explore: false,\n    compilerOptions: DEFAULT_COMPILER_OPTIONS,\n    types: false\n  };\n\n  const explore = userExplore ?? false;\n  const types = userTypes ?? false;\n\n  // Build a program using the set of root file names in fileNames\n  const program = createProgram(inputFiles, compilerOptions ?? DEFAULT_COMPILER_OPTIONS);\n\n  const programSourceFiles = program.getSourceFiles();\n\n  const filenamesFullPaths: string[] = inputFiles.map((fileName: string) => resolve(fileName));\n\n  // Visit only the files specified by the developers - no deep visit\n  const sourceFiles = programSourceFiles.filter(\n    ({isDeclarationFile, fileName}) =>\n      !isDeclarationFile && (explore || filenamesFullPaths.includes(resolve(fileName)))\n  );\n\n  // Get the checker, we will use it to find more about classes\n  const checker = program.getTypeChecker();\n\n  const result: DocEntry[] = [];\n\n  // Visit every sourceFile in the program\n  for (const sourceFile of sourceFiles) {\n    // Walk the tree to search for classes\n    forEachChild(sourceFile, (node: Node) => {\n      const entries: DocEntry[] = visit({checker, node, sourceFile, repo, types});\n      result.push(...entries);\n    });\n  }\n\n  return result;\n};\n"],
  "mappings": "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",
  "names": ["relative", "resolve", "ModifierFlags", "ModuleKind", "NodeFlags", "ScriptTarget", "SyntaxKind", "createProgram", "displayPartsToString", "forEachChild", "getCombinedModifierFlags", "isArrowFunction", "isClassDeclaration", "isEnumDeclaration", "isFunctionDeclaration", "isIdentifier", "isInterfaceDeclaration", "isMethodDeclaration", "isModuleDeclaration", "isPropertyDeclaration", "isPropertySignature", "isTypeAliasDeclaration", "isVariableDeclaration", "isVariableStatement", "serializeSymbol", "checker", "symbol", "doc_type", "serializeEnum", "members", "properties", "member", "_a", "documentation", "type", "serializeClass", "details", "constructorType", "signature", "serializeSignature", "isNodeExportedOrPublic", "node", "flags", "result", "findDescendantArrowFunction", "isTypeKind", "kind", "getRootParentName", "isRootOrClassLevelArrowFunction", "parent", "visit", "types", "rest", "entries", "pushEntry", "buildSource", "addDocEntry", "classEntry", "_b", "docEntries", "omitFilename", "_", "arrowFunc", "parentName", "declarations", "interfaceEntry", "child", "typeEntry", "DEFAULT_COMPILER_OPTIONS", "repo", "sourceFile", "fileName", "repoUrl", "branch", "line", "filePath", "url", "buildDocumentation", "inputFiles", "options", "compilerOptions", "userExplore", "userTypes", "explore", "program", "programSourceFiles", "filenamesFullPaths", "sourceFiles", "isDeclarationFile"]
}
