{
  "version": 3,
  "sources": ["../../src/lib/index.ts", "../../src/lib/docs.ts", "../../src/lib/markdown.ts"],
  "sourcesContent": ["import {existsSync, readFileSync, writeFileSync} from 'fs';\nimport {buildDocumentation} from './docs';\nimport {documentationToMarkdown} from './markdown';\nimport type {\n  BuildOptions,\n  DocEntry,\n  DocEntryConstructor,\n  DocEntryType,\n  MarkdownOptions\n} from './types';\n\nexport {buildDocumentation, documentationToMarkdown};\nexport type {DocEntry, DocEntryConstructor, DocEntryType};\n\n/**\n * Generate documentation and write output to a file.\n * If the file exists, it will try to insert the docs between <!-- TSDOC_START --> and <!-- TSDOC_END --> comments.\n * If these does not exist, the output file will be overwritten.\n *\n * @param {inputFiles: string[]; outputFile: string; markdownOptions?: MarkdownOptions; buildOptions?: BuildOptions;} params\n * @param params.inputFiles The list of files to scan for documentation. Absolute or relative path.\n * @param params.outputFile The file to output the documentation in Markdown.\n * @param params.markdownOptions Optional settings passed to the Markdown parser. See `MarkdownOptions` for details.\n * @param params.buildOptions Options to construct the documentation tree. See `BuildOptions` for details.\n */\nexport const generateDocumentation = ({\n  inputFiles,\n  outputFile,\n  markdownOptions,\n  buildOptions\n}: {\n  inputFiles: string[];\n  outputFile: string;\n  markdownOptions?: MarkdownOptions;\n  buildOptions?: BuildOptions;\n}) => {\n  const entries: DocEntry[] = buildDocumentation({\n    inputFiles: inputFiles,\n    options: buildOptions\n  });\n\n  const markdown: string = documentationToMarkdown({entries, options: markdownOptions});\n\n  if (existsSync(outputFile)) {\n    const fileContent = readFileSync(outputFile, 'utf-8');\n\n    const regex = /(<!-- TSDOC_START -->)[\\s\\S]*?(<!-- TSDOC_END -->)$/gm;\n\n    if (!fileContent.match(regex)) {\n      writeFileSync(outputFile, markdown, 'utf-8');\n      return;\n    }\n\n    const replace = `<!-- TSDOC_START -->\\n\\n${markdown}\\n<!-- TSDOC_END -->`;\n\n    writeFileSync(outputFile, fileContent.replace(regex, replace), 'utf-8');\n\n    return;\n  }\n\n  writeFileSync(outputFile, markdown, 'utf-8');\n};\n", "import {relative, resolve} from 'path/posix';\nimport type {\n  ArrowFunction,\n  CompilerOptions,\n  Declaration,\n  EnumDeclaration,\n  FunctionDeclaration,\n  Node,\n  PropertyName,\n  Signature,\n  SourceFile,\n  TypeChecker,\n  Symbol as TypeScriptSymbol,\n  VariableDeclaration,\n  VariableStatement\n} from 'typescript';\nimport {\n  ModifierFlags,\n  ModuleKind,\n  NodeFlags,\n  ScriptTarget,\n  SyntaxKind,\n  createProgram,\n  displayPartsToString,\n  forEachChild,\n  getCombinedModifierFlags,\n  isArrowFunction,\n  isClassDeclaration,\n  isEnumDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isInterfaceDeclaration,\n  isMethodDeclaration,\n  isModuleDeclaration,\n  isPropertyDeclaration,\n  isPropertySignature,\n  isTypeAliasDeclaration,\n  isVariableDeclaration,\n  isVariableStatement\n} from 'typescript';\nimport type {BuildOptions, DocEntry, DocEntryConstructor, DocEntryType} from './types';\n\n/** Serialize a symbol into a json object */\nconst serializeSymbol = ({\n  checker,\n  symbol,\n  doc_type\n}: {\n  checker: TypeChecker;\n  symbol: TypeScriptSymbol;\n  doc_type?: DocEntryType;\n}): DocEntry => {\n  return {\n    name: symbol.getName(),\n    documentation: displayPartsToString(symbol.getDocumentationComment(checker)),\n    type: checker.typeToString(checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration!)),\n    jsDocs: symbol.getJsDocTags(),\n    ...(doc_type && {doc_type})\n  };\n};\n\nconst serializeEnum = ({\n  checker,\n  symbol,\n  doc_type\n}: {\n  checker: TypeChecker;\n  symbol: TypeScriptSymbol;\n  doc_type?: DocEntryType;\n}): DocEntry => {\n  const {members} = symbol.valueDeclaration as EnumDeclaration;\n\n  const properties: DocEntry[] = members.map((member) => {\n    const documentation = displayPartsToString(\n      (member as unknown as {symbol: TypeScriptSymbol}).symbol.getDocumentationComment(checker)\n    );\n\n    const type = member.initializer?.getText();\n\n    return {\n      name: member.name.getText(),\n      ...(type !== undefined && {type}),\n      ...(documentation !== undefined && documentation !== '' && {documentation})\n    };\n  });\n\n  return {\n    name: symbol.getName(),\n    documentation: displayPartsToString(symbol.getDocumentationComment(checker)),\n    properties,\n    jsDocs: symbol.getJsDocTags(),\n    doc_type: doc_type ?? 'enum'\n  };\n};\n\n/** Serialize a class symbol information */\nconst serializeClass = ({\n  checker,\n  symbol\n}: {\n  checker: TypeChecker;\n  symbol: TypeScriptSymbol;\n}): DocEntry => {\n  const details = serializeSymbol({checker, symbol, doc_type: 'class'});\n\n  // Get the construct signatures\n  const constructorType = checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration!);\n\n  details.constructors = constructorType\n    .getConstructSignatures()\n    .map((signature: Signature) => serializeSignature({checker, signature}))\n    .filter(({documentation}) => documentation !== undefined && documentation !== '');\n\n  return details;\n};\n\n/** True if this is visible outside this file, false otherwise */\nconst isNodeExportedOrPublic = (node: Node): boolean => {\n  const flags = getCombinedModifierFlags(node as Declaration);\n\n  // Check for '#' methods or properties\n  if (\n    (isMethodDeclaration(node) || isPropertyDeclaration(node)) &&\n    node.name.kind === SyntaxKind.PrivateIdentifier\n  ) {\n    return false;\n  }\n\n  return (\n    (flags & ModifierFlags.Export) !== 0 ||\n    (flags & ModifierFlags.Public) !== 0 ||\n    (isClassDeclaration(node.parent) && [ModifierFlags.None, ModifierFlags.Static].includes(flags))\n  );\n};\n\n/** Serialize a signature (call or construct) */\nconst serializeSignature = ({\n  checker,\n  signature\n}: {\n  checker: TypeChecker;\n  signature: Signature;\n}): DocEntryConstructor => {\n  const result: Omit<DocEntryConstructor, 'visibility'> = {\n    parameters: signature.parameters.map((symbol: TypeScriptSymbol) =>\n      serializeSymbol({checker, symbol})\n    ),\n    returnType: checker.typeToString(signature.getReturnType()),\n    documentation: displayPartsToString(signature.getDocumentationComment(checker))\n  };\n\n  if (!!signature.declaration && 'modifiers' in signature.declaration) {\n    return {\n      ...result,\n      visibility:\n        signature.declaration.modifiers?.[0].kind === SyntaxKind.PrivateKeyword\n          ? 'private'\n          : 'public'\n    };\n  }\n\n  return {\n    ...result,\n    visibility: 'public'\n  };\n};\n\n// https://stackoverflow.com/a/73338964/5404186\nconst findDescendantArrowFunction = (node: Node): Node | undefined => {\n  if (isArrowFunction(node)) {\n    return node;\n  }\n\n  return forEachChild(node, findDescendantArrowFunction);\n};\n\n// TODO: there is probably a better way\nconst isTypeKind = (kind: SyntaxKind): boolean => {\n  const typeKinds: SyntaxKind[] = [\n    SyntaxKind.TypePredicate,\n    SyntaxKind.TypeReference,\n    SyntaxKind.FunctionType,\n    SyntaxKind.ConstructorType,\n    SyntaxKind.TypeQuery,\n    SyntaxKind.TypeLiteral,\n    SyntaxKind.ArrayType,\n    SyntaxKind.TupleType,\n    SyntaxKind.OptionalType,\n    SyntaxKind.RestType,\n    SyntaxKind.UnionType,\n    SyntaxKind.IntersectionType,\n    SyntaxKind.ConditionalType,\n    SyntaxKind.InferType,\n    SyntaxKind.ParenthesizedType,\n    SyntaxKind.ThisType,\n    SyntaxKind.TypeOperator,\n    SyntaxKind.IndexedAccessType,\n    SyntaxKind.MappedType,\n    SyntaxKind.LiteralType,\n    SyntaxKind.NamedTupleMember,\n    SyntaxKind.TemplateLiteralType,\n    // SyntaxKind.TemplateLiteralTypeSpan, // This is more of a structural part of template literal types\n    SyntaxKind.ImportType\n  ];\n\n  return typeKinds.includes(kind);\n};\n\nconst getRootParentName = (node: Node): string | undefined => {\n  if (!node.parent) {\n    return undefined;\n  }\n\n  if (isVariableDeclaration(node.parent) && isIdentifier(node.parent.name)) {\n    return node.parent.name.text;\n  }\n\n  return getRootParentName(node.parent);\n};\n\nconst isRootOrClassLevelArrowFunction = (node: Node): boolean => {\n  const parent = node.parent;\n\n  if (!parent) {\n    return false;\n  }\n\n  if (parent.kind === SyntaxKind.SourceFile) {\n    return true;\n  }\n\n  if (parent.kind === SyntaxKind.ClassDeclaration) {\n    return true;\n  }\n\n  if (\n    parent.kind === SyntaxKind.FunctionDeclaration ||\n    parent.kind === SyntaxKind.FunctionExpression ||\n    parent.kind === SyntaxKind.ArrowFunction\n  ) {\n    return false;\n  }\n\n  if (\n    parent.kind === SyntaxKind.PropertyAssignment ||\n    parent.kind === SyntaxKind.ObjectLiteralExpression\n  ) {\n    return false;\n  }\n\n  return isRootOrClassLevelArrowFunction(parent);\n};\n\n/** visit nodes finding exported classes */\nconst visit = ({\n  checker,\n  node,\n  types,\n  ...rest\n}: {checker: TypeChecker; node: Node} & Source &\n  Required<Pick<BuildOptions, 'types'>>): DocEntry[] => {\n  // // Only consider exported nodes\n  if (!isNodeExportedOrPublic(node)) {\n    return [];\n  }\n\n  const entries: DocEntry[] = [];\n\n  const pushEntry = ({details, node}: {details: DocEntry; node: Node}) => {\n    entries.push({\n      ...details,\n      ...buildSource({\n        node,\n        ...rest\n      })\n    });\n  };\n\n  const addDocEntry = ({\n    symbol,\n    doc_type,\n    node\n  }: {\n    symbol: TypeScriptSymbol | undefined;\n    doc_type: DocEntryType;\n    node: Node;\n  }) => {\n    if (!symbol) {\n      return;\n    }\n\n    const details = serializeSymbol({checker, symbol, doc_type});\n    pushEntry({node, details});\n  };\n\n  if (isClassDeclaration(node) && node.name) {\n    // This is a top level class, get its symbol\n    const symbol = checker.getSymbolAtLocation(node.name);\n\n    if (symbol) {\n      const classEntry: DocEntry = {\n        ...serializeClass({checker, symbol}),\n        methods: [],\n        properties: [],\n        ...buildSource({\n          node,\n          ...rest\n        })\n      };\n\n      const visitChild = (node: Node) => {\n        const docEntries: DocEntry[] = visit({node, checker, types, ...rest});\n\n        // We do not need to repeat the file name for class members\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const omitFilename = ({fileName: _, ...rest}: DocEntry): Omit<DocEntry, 'fileName'> => rest;\n\n        classEntry.methods?.push(\n          ...docEntries\n            .filter(({doc_type}) => doc_type === 'method' || doc_type === 'function')\n            .map(omitFilename)\n        );\n\n        classEntry.properties?.push(\n          ...docEntries.filter(({doc_type}) => doc_type === 'property').map(omitFilename)\n        );\n      };\n\n      forEachChild(node, visitChild);\n\n      entries.push(classEntry);\n    }\n  } else if (isModuleDeclaration(node)) {\n    const visitChild = (node: Node) => {\n      const docEntries: DocEntry[] = visit({node, checker, types, ...rest});\n      entries.push(...docEntries);\n    };\n\n    // This is a namespace, visit its children\n    forEachChild(node, visitChild);\n  } else if (isMethodDeclaration(node)) {\n    const symbol = checker.getSymbolAtLocation(node.name);\n    addDocEntry({symbol, doc_type: 'method', node});\n  } else if (isFunctionDeclaration(node)) {\n    const symbol = checker.getSymbolAtLocation((node as FunctionDeclaration).name ?? node);\n    addDocEntry({symbol, doc_type: 'function', node});\n  } else {\n    const arrowFunc: Node | undefined = findDescendantArrowFunction(node);\n\n    if (arrowFunc !== undefined) {\n      const symbol = checker.getSymbolAtLocation(\n        ((arrowFunc as ArrowFunction).parent as VariableDeclaration).name\n      );\n\n      if (symbol !== undefined) {\n        const parentName = !isRootOrClassLevelArrowFunction(arrowFunc)\n          ? getRootParentName(arrowFunc)\n          : undefined;\n\n        const details = serializeSymbol({checker, symbol, doc_type: 'function'});\n        pushEntry({\n          node,\n          details: {\n            ...details,\n            name: parentName !== undefined ? `${parentName}.${details.name}` : details.name\n          }\n        });\n      }\n    } else if (isPropertyDeclaration(node)) {\n      // We test for the property after the arrow function because a public property of a class can be an arrow function.\n      const symbol = checker.getSymbolAtLocation(node.name);\n      addDocEntry({symbol, doc_type: 'property', node});\n    } else if (isVariableStatement(node)) {\n      const {\n        declarationList: {declarations, flags}\n      } = node as VariableStatement;\n\n      // https://stackoverflow.com/a/69801125/5404186\n      const isConst = (flags & NodeFlags.Const) !== 0;\n\n      if (isConst) {\n        // TODO: not sure what's the proper casting, VariableDeclaration does not contain Symbol but the test entity effectively does\n        const symbol = (declarations[0] as unknown as {symbol: TypeScriptSymbol}).symbol;\n        addDocEntry({symbol, doc_type: 'const', node});\n      }\n    } else if (types && isInterfaceDeclaration(node)) {\n      const symbol = checker.getSymbolAtLocation(node.name);\n\n      if (symbol) {\n        const members = node.members\n          .filter(\n            (member) =>\n              isPropertySignature(member) && member.name !== undefined && isIdentifier(member.name)\n          )\n          .map((member) => checker.getSymbolAtLocation(member.name as PropertyName))\n          .filter((symbol) => symbol !== undefined)\n          .map((symbol) => serializeSymbol({checker, symbol: symbol as TypeScriptSymbol}));\n\n        const interfaceEntry: DocEntry = {\n          ...serializeSymbol({checker, doc_type: 'interface', symbol}),\n          properties: members,\n          ...buildSource({\n            node,\n            ...rest\n          })\n        };\n\n        entries.push(interfaceEntry);\n      }\n    } else if (types && isTypeAliasDeclaration(node)) {\n      const symbol = checker.getSymbolAtLocation(node.name);\n\n      if (symbol) {\n        const child = node.getChildren().find(({kind}) => isTypeKind(kind));\n\n        const typeEntry: DocEntry = {\n          ...serializeSymbol({checker, doc_type: 'type', symbol}),\n          ...buildSource({\n            node,\n            ...rest\n          }),\n          type: child?.getText().replace(/^\"|\"$/g, '')\n        };\n\n        entries.push(typeEntry);\n      }\n    } else if (isEnumDeclaration(node)) {\n      const symbol = checker.getSymbolAtLocation((node as EnumDeclaration).name)!;\n      const details = serializeEnum({checker, symbol});\n      pushEntry({node, details});\n    }\n  }\n\n  return entries;\n};\n\nconst DEFAULT_COMPILER_OPTIONS: CompilerOptions = {\n  target: ScriptTarget.ES2020,\n  module: ModuleKind.CommonJS,\n  strictNullChecks: true\n};\n\ntype Source = Pick<BuildOptions, 'repo'> & {sourceFile: SourceFile};\n\nconst buildSource = ({\n  repo,\n  node,\n  sourceFile\n}: Source & {node: Node}): Pick<DocEntry, 'url' | 'fileName'> => {\n  const fileName = sourceFile.fileName;\n\n  if (repo === undefined) {\n    return {fileName};\n  }\n\n  const {url: repoUrl, branch} = repo;\n\n  const {line} = sourceFile.getLineAndCharacterOfPosition(node.getStart());\n  const filePath = relative(process.cwd(), sourceFile.fileName);\n\n  const url = `${repoUrl.replace(/\\/+$/, '')}/tree/${branch ?? 'main'}/${filePath.replace(\n    /^\\.\\.\\//,\n    ''\n  )}#L${line + 1}`;\n\n  return {\n    fileName,\n    url\n  };\n};\n\n/**\n * Build the documentation entries for the selected sources.\n *\n * @param {inputFiles: string[]; options?: CompilerOptions;} params\n * @param {string[]} params.inputFiles The list of files to scan and for which the documentation should be build.\n * @param {CompilerOptions} params.options Optional compiler options to generate the docs\n *\n * @returns An array of documentation entries\n */\nexport const buildDocumentation = ({\n  inputFiles,\n  options\n}: {\n  inputFiles: string[];\n  options?: BuildOptions;\n}): DocEntry[] => {\n  const {\n    compilerOptions,\n    explore: userExplore,\n    repo,\n    types: userTypes\n  } = options ?? {\n    explore: false,\n    compilerOptions: DEFAULT_COMPILER_OPTIONS,\n    types: false\n  };\n\n  const explore = userExplore ?? false;\n  const types = userTypes ?? false;\n\n  // Build a program using the set of root file names in fileNames\n  const program = createProgram(inputFiles, compilerOptions ?? DEFAULT_COMPILER_OPTIONS);\n\n  const programSourceFiles = program.getSourceFiles();\n\n  const filenamesFullPaths: string[] = inputFiles.map((fileName: string) => resolve(fileName));\n\n  // Visit only the files specified by the developers - no deep visit\n  const sourceFiles = programSourceFiles.filter(\n    ({isDeclarationFile, fileName}) =>\n      !isDeclarationFile && (explore || filenamesFullPaths.includes(resolve(fileName)))\n  );\n\n  // Get the checker, we will use it to find more about classes\n  const checker = program.getTypeChecker();\n\n  const result: DocEntry[] = [];\n\n  // Visit every sourceFile in the program\n  for (const sourceFile of sourceFiles) {\n    // Walk the tree to search for classes\n    forEachChild(sourceFile, (node: Node) => {\n      const entries: DocEntry[] = visit({checker, node, sourceFile, repo, types});\n      result.push(...entries);\n    });\n  }\n\n  return result;\n};\n", "import type {JSDocTagInfo, SymbolDisplayPart} from 'typescript';\nimport type {\n  DocEntry,\n  DocEntryConstructor,\n  MarkdownEmoji,\n  MarkdownHeadingLevel,\n  MarkdownOptions\n} from './types';\n\ntype Params = {name: string; documentation: string};\n\ntype Row = Required<Pick<DocEntry, 'name' | 'type' | 'documentation'>> &\n  Pick<DocEntry, 'url'> & {\n    params: Params[];\n    examples: string[];\n  };\n\nconst toParams = (parameters?: DocEntry[]): Params[] =>\n  (parameters ?? []).map(({name, documentation}: DocEntry) => ({\n    name,\n    documentation: documentation ?? ''\n  }));\n\nconst inlineDocParam = (documentation: string | undefined): string =>\n  documentation !== undefined && documentation !== '' ? `: ${documentation}` : '';\n\nconst inlineParams = (params: Params[]): string[] =>\n  params.map(({name, documentation}) => `* \\`${name}\\`${inlineDocParam(documentation)}`);\n\nconst classesToMarkdown = ({\n  entry,\n  headingLevel,\n  emoji\n}: {\n  entry: DocEntry;\n} & Required<Pick<MarkdownOptions, 'headingLevel'>> &\n  Omit<MarkdownOptions, 'headingLevel'>): string => {\n  const {name, url, documentation, methods, properties, constructors} = entry;\n\n  const markdown: string[] = [`${headingLevel}${emojiTitle({emoji, key: 'classes'})} ${name}\\n`];\n\n  if (documentation !== undefined && documentation !== '') {\n    markdown.push(`${documentation}\\n`);\n  }\n\n  if (url !== undefined) {\n    markdown.push(sourceCodeLink({emoji, url}));\n  }\n\n  const publicConstructors: DocEntryConstructor[] = (constructors ?? []).filter(\n    ({visibility}) => visibility === 'public'\n  );\n\n  if (publicConstructors?.length) {\n    markdown.push(`${headingLevel}# Constructors\\n`);\n\n    markdown.push(\n      ...publicConstructors.map(({parameters, documentation, visibility}) => {\n        const docs: string[] = [`\\`${visibility}\\`${inlineDocParam(documentation)}\\n`];\n\n        if (parameters?.length) {\n          docs.push(`Parameters:\\n`);\n          docs.push(...inlineParams(toParams(parameters)));\n        }\n\n        return docs.join('\\n');\n      })\n    );\n\n    markdown.push('\\n');\n  }\n\n  if ((methods?.length ?? 0) > 0) {\n    markdown.push(`${headingLevel}# Methods\\n`);\n    markdown.push(`${tableOfContent({entries: methods ?? [], emoji})}\\n`);\n\n    // Explicitly do not pass repo to generate the source code link afterwards for the all block\n    markdown.push(\n      `${toMarkdown({\n        entries: methods ?? [],\n        headingLevel: `${headingLevel}#`,\n        docType: 'Method',\n        emoji\n      })}`\n    );\n  }\n\n  if ((properties?.length ?? 0) > 0) {\n    markdown.push(`${headingLevel}# Properties\\n`);\n    markdown.push(`${tableOfContent({entries: properties ?? [], emoji})}\\n`);\n\n    // Explicitly do not pass repo to generate the source code link afterwards for the all block\n    markdown.push(\n      `${toMarkdown({\n        entries: properties ?? [],\n        headingLevel: `${headingLevel}#`,\n        docType: 'Property',\n        emoji\n      })}`\n    );\n  }\n\n  return markdown.join('\\n');\n};\n\nconst interfacesToMarkdown = ({\n  entry,\n  headingLevel,\n  emoji\n}: {\n  entry: DocEntry;\n} & Required<Pick<MarkdownOptions, 'headingLevel'>> &\n  Omit<MarkdownOptions, 'headingLevel'> &\n  Pick<MarkdownOptions, 'emoji'>): string => {\n  const {name, documentation} = entry;\n\n  const markdown: string[] = [\n    `${headingLevel}# ${emoji === undefined || emoji === null ? '' : ':gear: '}${name}\\n`\n  ];\n\n  if (documentation !== undefined) {\n    markdown.push(`${documentation}\\n`);\n  }\n\n  markdown.push(`| Property | Type | Description |`);\n  markdown.push('| ---------- | ---------- | ---------- |');\n\n  (entry.properties ?? []).forEach(({name, type, documentation, jsDocs}) => {\n    const jsDocsDescription = (jsDocs ?? []).map(\n      ({name, text}: JSDocTagInfo) =>\n        `${name}${text !== undefined ? `: ${text.map(({text}) => text).join('')}` : ''}`\n    );\n\n    markdown.push(\n      `| \\`${name}\\` | \\`${parseType(type ?? '')}\\` | ${documentation !== undefined && documentation !== '' ? `${parseType(documentation).replace(/\\r?\\n|\\r/g, '')}` : ''}${jsDocsDescription.length > 0 ? ` ${parseType(jsDocsDescription.join(''))}` : ''} |`\n    );\n  });\n\n  markdown.push('\\n');\n\n  return markdown.join('\\n');\n};\n\nconst sourceCodeLink = ({\n  url,\n  emoji\n}: Pick<MarkdownOptions, 'emoji'> & Required<Pick<DocEntry, 'url'>>): string =>\n  `[${emojiTitle({emoji, key: 'link'}).trim()}${emoji !== null && emoji !== undefined ? ' ' : ''}Source](${url})\\n`;\n\n// Avoid issue if the Markdown table gets formatted with Prettier\nconst parseType = (type: string): string =>\n  type\n    .split('\\n')\n    .map((line) => line.trim())\n    .join(' ')\n    .replace(/ \\| /g, ' or ')\n    .replace(/ & /g, ' and ');\n\nconst toMarkdown = ({\n  entries,\n  headingLevel,\n  docType,\n  emoji\n}: {\n  entries: DocEntry[];\n  headingLevel: MarkdownHeadingLevel | '####';\n  docType: 'Constant' | 'Function' | 'Method' | 'Property' | 'Type' | 'Enum';\n} & Pick<MarkdownOptions, 'emoji'>): string => {\n  const jsDocsToParams = (jsDocs: JSDocTagInfo[]): Params[] => {\n    const params: JSDocTagInfo[] = jsDocs.filter(({name}: JSDocTagInfo) => name === 'param');\n    const texts: (SymbolDisplayPart[] | undefined)[] = params.map(({text}) => text);\n\n    const parts: SymbolDisplayPart[][] = texts.reduce(\n      (acc: SymbolDisplayPart[][], values: SymbolDisplayPart[] | undefined) => {\n        if (values === undefined) {\n          return acc;\n        }\n\n        return [...acc, values];\n      },\n      []\n    );\n\n    const toParam = (parts: SymbolDisplayPart[]): Params | undefined => {\n      if (parts.find(({kind, text}) => kind === 'parameterName' && text !== '') === undefined) {\n        return undefined;\n      }\n\n      const name = parts.find(({kind}) => kind === 'parameterName')?.text ?? '';\n      const documentation = parts.find(({kind}) => kind === 'text')?.text ?? '';\n\n      return {name, documentation};\n    };\n\n    return parts.map(toParam).filter((param) => param !== undefined) as Params[];\n  };\n  const jsDocsToExamples = (jsDocs: JSDocTagInfo[]): string[] => {\n    const examples: JSDocTagInfo[] = jsDocs.filter(({name}: JSDocTagInfo) => name === 'example');\n    const texts = examples\n      .map(({text}) => text)\n      .filter(Boolean)\n      .flat(1) as SymbolDisplayPart[];\n    return texts.map(({text}) => text).filter(Boolean);\n  };\n\n  const rows: Row[] = entries.map(\n    ({name, type, documentation, parameters, jsDocs, url}: DocEntry) => ({\n      name,\n      type: type ?? '',\n      documentation: documentation ?? '',\n      params: [...toParams(parameters), ...jsDocsToParams(jsDocs ?? [])],\n      examples: [...jsDocsToExamples(jsDocs ?? [])],\n      url\n    })\n  );\n\n  const rowToMarkdown = ({name, documentation, type, params, examples, url}: Row): string => {\n    const markdown: string[] = [\n      `${headingLevel}# ${emoji === undefined || emoji === null ? '' : ':gear: '}${name}\\n`\n    ];\n\n    if (documentation.length) {\n      markdown.push(`${documentation}\\n`);\n    }\n\n    markdown.push(`| ${type === 'Type' ? 'Type alias' : docType} | Type |`);\n    markdown.push('| ---------- | ---------- |');\n    markdown.push(\n      `| \\`${name}\\` | ${type !== undefined && type !== '' ? `\\`${parseType(type)}\\`` : ''} |\\n`\n    );\n\n    if (params.length) {\n      markdown.push('Parameters:\\n');\n      markdown.push(...inlineParams(params));\n      markdown.push('\\n');\n    }\n    if (examples.length) {\n      markdown.push('Examples:\\n');\n      markdown.push(...examples);\n      markdown.push('\\n');\n    }\n    if (url !== undefined) {\n      markdown.push(sourceCodeLink({emoji, url}));\n    }\n\n    return markdown.join('\\n');\n  };\n\n  return rows.map(rowToMarkdown).join('\\n');\n};\n\nconst tableOfContent = ({\n  entries,\n  emoji\n}: {\n  entries: DocEntry[];\n} & Pick<MarkdownOptions, 'emoji'>): string =>\n  entries\n    .map(\n      ({name}) =>\n        `- [${name}](#${emoji === undefined || emoji === null ? '' : `${emoji.entry}-`}${name\n          .toLowerCase()\n          .replace(/ /g, '-')})`\n    )\n    .join('\\n');\n\nconst emojiTitle = ({\n  emoji,\n  key\n}: {\n  key: keyof MarkdownEmoji;\n} & Pick<MarkdownOptions, 'emoji'>): string =>\n  emoji === undefined || emoji === null ? '' : ` :${emoji[key]}:`;\n\nconst DEFAULT_EMOJI: MarkdownEmoji = {\n  classes: 'factory',\n  functions: 'toolbox',\n  constants: 'wrench',\n  enum: 'nut_and_bolt',\n  entry: 'gear',\n  link: 'link',\n  interfaces: 'tropical_drink',\n  types: 'cocktail'\n};\n\n/**\n * Convert the documentation entries to an opinionated Markdown format.\n *\n * @param {entries: DocEntry[]; options: MarkdownOptions;} params\n * @param params.entries The entries of the documentation (functions, constants and classes).\n * @param params.options Optional configuration to render the Markdown content. See `types.ts` for details.\n */\nexport const documentationToMarkdown = ({\n  entries,\n  options\n}: {\n  entries: DocEntry[];\n  options?: MarkdownOptions;\n}): string => {\n  const {headingLevel: userHeadingLevel, emoji: userEmoji} = options ?? {\n    headingLevel: '##',\n    emoji: DEFAULT_EMOJI\n  };\n\n  const headingLevel = userHeadingLevel ?? '##';\n\n  const emoji: MarkdownEmoji | undefined =\n    userEmoji === null ? undefined : (userEmoji ?? DEFAULT_EMOJI);\n\n  const functions: DocEntry[] = entries.filter(({doc_type}: DocEntry) => doc_type === 'function');\n  const classes: DocEntry[] = entries.filter(({doc_type}: DocEntry) => doc_type === 'class');\n  const constants: DocEntry[] = entries.filter(({doc_type}: DocEntry) => doc_type === 'const');\n  const enums: DocEntry[] = entries.filter(({doc_type}: DocEntry) => doc_type === 'enum');\n  const types: DocEntry[] = entries.filter(({doc_type}: DocEntry) => doc_type === 'type');\n  const interfaces: DocEntry[] = entries.filter(({doc_type}: DocEntry) => doc_type === 'interface');\n\n  const markdown: string[] = [];\n\n  if (functions.length) {\n    markdown.push(`${headingLevel}${emojiTitle({emoji, key: 'functions'})} Functions\\n`);\n    markdown.push(`${tableOfContent({entries: functions, emoji})}\\n`);\n    markdown.push(\n      `${toMarkdown({entries: functions, headingLevel, emoji, docType: 'Function'})}\\n`\n    );\n  }\n\n  if (constants.length) {\n    markdown.push(`${headingLevel}${emojiTitle({emoji, key: 'constants'})} Constants\\n`);\n    markdown.push(`${tableOfContent({entries: constants, emoji})}\\n`);\n    markdown.push(\n      `${toMarkdown({entries: constants, headingLevel, emoji, docType: 'Constant'})}\\n`\n    );\n  }\n  markdown.push(\n    classes.map((entry: DocEntry) => classesToMarkdown({entry, headingLevel, emoji})).join('\\n')\n  );\n  if (enums.length) {\n    markdown.push(`${headingLevel}${emojiTitle({emoji, key: 'enum'})} Enum\\n`);\n    markdown.push(`${tableOfContent({entries: enums, emoji})}\\n`);\n    markdown.push(\n      enums.map((entry: DocEntry) => interfacesToMarkdown({entry, headingLevel, emoji})).join('\\n')\n    );\n  }\n  if (interfaces.length) {\n    markdown.push(`${headingLevel}${emojiTitle({emoji, key: 'interfaces'})} Interfaces\\n`);\n    markdown.push(`${tableOfContent({entries: interfaces, emoji})}\\n`);\n    markdown.push(\n      interfaces\n        .map((entry: DocEntry) => interfacesToMarkdown({entry, headingLevel, emoji}))\n        .join('\\n')\n    );\n  }\n\n  if (types.length) {\n    markdown.push(`${headingLevel}${emojiTitle({emoji, key: 'types'})} Types\\n`);\n    markdown.push(`${tableOfContent({entries: types, emoji})}\\n`);\n    markdown.push(`${toMarkdown({entries: types, headingLevel, emoji, docType: 'Type'})}\\n`);\n  }\n\n  return markdown.join('\\n');\n};\n"],
  "mappings": "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",
  "names": ["lib_exports", "__export", "buildDocumentation", "documentationToMarkdown", "generateDocumentation", "__toCommonJS", "import_fs", "import_posix", "import_typescript", "serializeSymbol", "checker", "symbol", "doc_type", "serializeEnum", "members", "properties", "member", "_a", "documentation", "type", "serializeClass", "details", "constructorType", "signature", "serializeSignature", "isNodeExportedOrPublic", "node", "flags", "result", "findDescendantArrowFunction", "isTypeKind", "kind", "getRootParentName", "isRootOrClassLevelArrowFunction", "parent", "visit", "types", "rest", "entries", "pushEntry", "buildSource", "addDocEntry", "classEntry", "_b", "docEntries", "omitFilename", "_", "arrowFunc", "parentName", "declarations", "interfaceEntry", "child", "typeEntry", "DEFAULT_COMPILER_OPTIONS", "repo", "sourceFile", "fileName", "repoUrl", "branch", "line", "filePath", "url", "buildDocumentation", "inputFiles", "options", "compilerOptions", "userExplore", "userTypes", "explore", "program", "programSourceFiles", "filenamesFullPaths", "sourceFiles", "isDeclarationFile", "toParams", "parameters", "name", "documentation", "inlineDocParam", "inlineParams", "params", "classesToMarkdown", "entry", "headingLevel", "emoji", "url", "methods", "properties", "constructors", "markdown", "emojiTitle", "sourceCodeLink", "publicConstructors", "visibility", "docs", "tableOfContent", "toMarkdown", "interfacesToMarkdown", "type", "jsDocs", "jsDocsDescription", "text", "parseType", "line", "entries", "docType", "jsDocsToParams", "parts", "acc", "values", "toParam", "_a", "_b", "kind", "param", "jsDocsToExamples", "rows", "rowToMarkdown", "examples", "key", "DEFAULT_EMOJI", "documentationToMarkdown", "options", "userHeadingLevel", "userEmoji", "functions", "doc_type", "classes", "constants", "enums", "types", "interfaces", "generateDocumentation", "inputFiles", "outputFile", "markdownOptions", "buildOptions", "entries", "buildDocumentation", "markdown", "documentationToMarkdown", "fileContent", "regex", "replace"]
}
